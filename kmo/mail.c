/* Copyright (C) 2006-2012 Opersys inc., All rights reserved. */

#include "mail.h"
#include "kmod.h"
#include "utils.h"
#include "kbuffer.h"

/* This function returns the packaging type string that must be placed after the
 * Kryptiva marker.
 */
char * mail_get_pkg_type_str(int pkg_type) {
    switch (pkg_type) {
	case KPP_SIGN_MAIL:
            return "PACKAGING TYPE: SIGNED";
	case KPP_SIGN_N_POD_MAIL:
            return "PACKAGING TYPE: SIGNED WITH PROOF OF DELIVERY";
	case KPP_SIGN_N_ENCRYPT_MAIL:
            return "PACKAGING TYPE: SIGNED AND ENCRYPTED";
	case KPP_SIGN_N_ENCRYPT_N_POD_MAIL:
            return "PACKAGING TYPE: SIGNED AND ENCRYPTED WITH PROOF OF DELIVERY";
	default:
            assert(0);
	    return NULL;
    }
}

/* This function works around Outlook's HTML damage. Outlook injects the tag
 * <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
 * when it sends a mail to the SMTP server. Outlook removes it automatically
 * before it reaches the MSO plugin, but it breaks other MUAs. Furthemore,
 * Outlook removes any <meta ...> tags it finds in the messages generated by
 * other MUAs. Thus, if we find a <meta ...> tag, we replace it by spaces.
 * There can be many meta tags, from other MUAs and from Outlook.
 */
void mail_repair_outlook_html_damage(kstr *body) {
    char *pos = body->data;
    
    kmod_log_msg(2, "mail_repair_outlook_html_damage() called.\n");
    
    while (1) {
	pos = portable_strcasestr(pos, "<meta ");
	if (pos == NULL) return;

    	while (1) {
    	    if (! *pos) return;
	    
	    if (*pos == '>') {
	    	*pos = ' ';
		pos++;
		break;
	    }

	    *pos = ' ';
	    pos++;
	}
    }
}

/* This function strips everything outside the <html> and </html> tags, if they
 * are found. Otherwise, the function strips everything outside the kryptiva
 * tags, if they are found. Otherwise, nothing is done.
 */
void mail_get_signable_html_body(kstr *in, kstr *out) {
    char *strip_start;
    char *strip_end;
    
    kmod_log_msg(2, "mail_get_signable_html_body() called.\n");
    
    /* Try. */
    do {
    	char *tag_start;
	char *tag_end;
	
	/* Look for the <html> tags. */
	tag_start = portable_strcasestr(in->data, "<html");
	tag_end = portable_strcasestr(in->data, "</html>");
	
	if (tag_start != NULL && tag_end != NULL && tag_start < tag_end) {
	    strip_start = tag_start;
	    strip_end = tag_end + strlen("</html>");
	    break;
	}
	
	/* Look for the Kryptiva tags. */
	tag_start = portable_strcasestr(in->data, KRYPTIVA_BODY_START);
	tag_end = portable_strcasestr(in->data, KRYPTIVA_SIG_END);
	
	if (tag_start != NULL && tag_end != NULL && tag_start < tag_end) {
	    strip_start = tag_start - strlen("<pre>");
	    strip_end = tag_end + strlen(KRYPTIVA_SIG_END) + strlen("</pre>");
	    
	    if (strip_start >= in->data && strip_end <= in->data + in->slen) {
	    	break;
	    }
	}
	
	/* Forget about the tags. */
	strip_start = in->data;
	strip_end = in->data + in->slen;
	
    } while (0);
    
    kstr_assign_buf(out, strip_start, (strip_end - strip_start));
}

/* This function adds a space before the </body> tag, if it is found. This is a
 * kludge to make the HTML signature work.
 */
void mail_put_space_before_body_end(kstr *in) {
    kstr tmp;
    char *body_end = portable_strcasestr(in->data, "</body>");
    if (body_end == NULL) return;
    
    kstr_init(&tmp);
    kstr_append_buf(&tmp, in->data, body_end - in->data);
    kstr_append_char(&tmp, ' ');
    kstr_append_buf(&tmp, body_end, in->data + in->slen - body_end);
    kstr_assign_kstr(in, &tmp);
    kstr_free(&tmp);
}

/* This function inserts a signature in a text mail body. */
void mail_build_signed_text_body(int pkg_type, kstr *orig_body, kstr *sig, kstr *signed_body) {
    kmod_log_msg(2, "mail_build_signed_text_body() called.\n");
    
    kstr_clear(signed_body);

    /* Write the body header. */
    kstr_append_cstr(signed_body, KRYPTIVA_BODY_START);
    kstr_append_char(signed_body, '\n');
    
    /* Write the packaging type. */
    kstr_append_cstr(signed_body, mail_get_pkg_type_str(pkg_type));
    kstr_append_char(signed_body, '\n');

    /* Write the original body. */
    kstr_append_kstr(signed_body, orig_body);

    /* Write the signature. */
    kstr_append_kstr(signed_body, sig);
}

/* This function finds the last occurrence of the specified tag.
 * It returns NULL if the tag is not found.
 */
static char * mail_find_last_tag(char *where, char *tag) {
    char *last_tag = portable_strcasestr(where, tag);
    
    if (last_tag == NULL) {
    	return NULL;
    }
    
    while (1) {
    	char *ptr = portable_strcasestr(last_tag + strlen(tag), tag);
    	
	if (ptr) {
	    last_tag = ptr;
	}
	
	else {
	    return last_tag;
	}
    }
}

/* This function tries to find the tags specified for building an HTML body. It
 * returns true if the tags were found.
 */
static int mail_signed_find_html_tags(kstr *body, char *open_tag, char *close_tag,
    	    	    	    	      char **tag_open_start, char **tag_open_end, char **tag_close_start) {
    char *i;
    
    *tag_open_start = portable_strcasestr(body->data, open_tag);
    if (*tag_open_start == NULL) return 0;
    
    *tag_open_end = NULL;
    
    for (i = *tag_open_start; i < body->data + body->slen; i++) {
        if (*i == '>') {
	    *tag_open_end = i;
	    break;
        }
    }
    
    if (*tag_open_end == NULL) return 0;
    
    *tag_close_start = portable_strcasestr(*tag_open_end + 1, close_tag);
    return (*tag_close_start != NULL);
}

/* This function inserts a signature in a HTML mail body. */
void mail_build_signed_html_body(int pkg_type, kstr *orig_body, kstr *sig, kstr *signed_body) {
    char *tag_open_start, *tag_open_end, *tag_close_start;
    char *pre_header, *content, *post_footer;
    int pre_header_s, content_s, post_footer_s;
    
    kmod_log_msg(2, "mail_build_signed_html_body() called.\n");
    
    /* This code implements the algorithm written by Kritian Benoit in his KMI
     * Email Layout document, section 3.1. We suppose that the HTML is well
     * formed (that is, we can find an ending '>' for all tags).
     */
    
    /* Look for <body ...>, then look for <html ...>. */
    if (mail_signed_find_html_tags(orig_body, "<body", "</body>", &tag_open_start, &tag_open_end, &tag_close_start) ||
    	mail_signed_find_html_tags(orig_body, "<html", "</html>", &tag_open_start, &tag_open_end, &tag_close_start)) {
    	
	pre_header = orig_body->data;        
        pre_header_s = tag_open_end - orig_body->data + 1;
        content = tag_open_end + 1;
        content_s = tag_close_start - tag_open_end - 1;
        post_footer = tag_close_start;
        post_footer_s = orig_body->data + orig_body->slen - tag_close_start;
    }
    
    /* Don't try to make sense out of the HTML. */
    else {
        pre_header = NULL;
	pre_header_s = 0;
	content = orig_body->data;
	content_s = orig_body->slen;
	post_footer = NULL;
	post_footer_s = 0;
    }
    
    kstr_clear(signed_body);
    
    /* Write what should be before the header. */
    kstr_append_buf(signed_body, pre_header, pre_header_s);

    /* Write the body header. */
    kstr_append_cstr(signed_body, "\n<pre>");
    kstr_append_cstr(signed_body, KRYPTIVA_BODY_START);
    kstr_append_char(signed_body, '\n');

    /* Write the packaging type. */
    kstr_append_cstr(signed_body, mail_get_pkg_type_str(pkg_type));
    kstr_append_cstr(signed_body, "</pre>");

    /* Write the body content. */
    kstr_append_buf(signed_body, content, content_s);
    
    /* Write the signature. */
    kstr_append_cstr(signed_body, "\n<pre>");
    kstr_append_kstr(signed_body, sig);
    kstr_append_cstr(signed_body, "</pre>");

    /* Write what should be after the footer. */
    kstr_append_buf(signed_body, post_footer, post_footer_s);
}

/* This function builds an encrypted text body. */
void mail_build_encrypted_body(int pkg_type, kstr *content, kstr *encrypted_body) {
    kmod_log_msg(2, "mail_build_encrypted_body() called.\n");
    
    kstr_clear(encrypted_body);
    
    /* Write the body header. */
    kstr_append_cstr(encrypted_body, KRYPTIVA_BODY_START);
    kstr_append_char(encrypted_body, '\n');

    /* Write the packaging type. */
    kstr_append_cstr(encrypted_body, mail_get_pkg_type_str(pkg_type));
    kstr_append_char(encrypted_body, '\n');

    /* Write the new body content. */
    kstr_append_kstr(encrypted_body, content);
}

/* This function returns a pointer to the beginning of the '\n*<pre>\n*' string
 * that is supposed to appear before 'scan_str'. If the string is not found,
 * NULL is returned. If 'remove_leading_newline' is false, the newlines before
 * the <pre> tag are not removed. 
 */
static char * mail_remove_pre(char *mail_str, char *scan_str, int remove_leading_newline) {
    kmod_log_msg(2, "mail_remove_pre() called.\n");
    
    /* Look for <pre>. */
    scan_str--;
    
    while (scan_str >= mail_str) {
    	
	/* Skip whitespace. */
	if (*scan_str == ' ' || *scan_str == '\n' || *scan_str == '\r' || *scan_str == '\t') {
	    scan_str--;
	}
	
	/* Look for <pre>. */
	else {
	    char *possible_pre_start = scan_str - strlen("<pre>") + 1;
	    
	    if (possible_pre_start >= mail_str) {
	    	
		/* OK we found it, keep going. */
		if (portable_strncasecmp(possible_pre_start, "<pre>", strlen("<pre>")) == 0) {
		    
		    /* Just skip the <pre> if remove_leading_newline is false. */
		    if (! remove_leading_newline) {
		    	return possible_pre_start;
		    }
		    
		    scan_str = possible_pre_start - 1;
		    break;
		}
	    }
	    
	    /* Oops, abort. */
	    return NULL;
	}
    }
    
    /* Skip the whitespaces until we find a non-whitespace character or we reach
     * the beginning of the mail.
     */
    while (scan_str >= mail_str) {
    	
	/* Skip whitespace. */
	if (*scan_str == ' ' || *scan_str == '\n' || *scan_str == '\r' || *scan_str == '\t') {
	    scan_str--;
	}
	
	/* Non-whitespace character. We're done. */
	else {
	    return scan_str + 1;
	}
    }

    /* Beginning of mail. */
    return mail_str;
}

/* This function returns 0 if the mail specified is a gray Zone mail, 1 if it is
 * a Kryptiva mail, and 2 if it is an unsigned mail. NULL bodies are ignored.
 */
int mail_get_mail_status(kstr *text_body, kstr *html_body) {
    
    /* Status as described above, plus '3' for empty body. */
    int text_status = 3;
    int html_status = 3;
    int decision;
    
    /* Decision table, indexed with text & html statuses. */
    static int decision_table[4][4] = { { 0, 0, 0, 0 },
    	    	    	    	    	{ 0, 1, 0, 1 },
					{ 0, 0, 2, 2 },
					{ 0, 1, 2, 2 } };
    
    kmod_log_msg(2, "mail_get_mail_status() called.\n");
    
    if (text_body) {
    	char *data = text_body->data;
    	char *marker = portable_strcasestr(data, KRYPTIVA_BODY_START);
    	
	kmod_log_msg(3, "mail_get_mail_status(): scanning the text body.\n");
	
	/* We found the tag. */
	if (marker) {
	    
	    kmod_log_msg(3, "mail_get_mail_status(): found the Kryptiva marker in the text body.\n");
	    
	    /* It is located at beginning of the top line, so this is a Kryptiva body. */
	    if (marker == data) {
	    	kmod_log_msg(3, "mail_get_mail_status(): the Kryptiva marker is at the beginning "
		    	        "of the top text line.\n");
	    	text_status = 1;
	    }
	    
	    /* It is not located at the beginning of a line, so this is not a
	     * Kryptiva body.
	     */
	    else if (marker[-1] != '\r' && marker[-1] != '\n') {
	    	kmod_log_msg(3, "mail_get_mail_status(): the Kryptiva marker is not at the beginning "
		    	    	"of a text line.\n");
	    	text_status = 2;
	    }
	    
	    /* It is located at the beginning of a line, so this might be a Kryptiva
	     * body.
	     */
	    else {
	    	marker--;
		
		while (marker != data) {
		    
		    /* There is a non-whitespace character above the tag, so this a gray
		     * zone body.
		     */
		    if (*marker != '\t' && *marker != ' ' && *marker != '\n' && *marker != '\r') {
		    	kmod_log_msg(3, "mail_get_mail_status(): the Kryptiva marker is at the beginning "
			    	    	"of a text line, but there are non-whitespace characters above it.");
		    	text_status = 0;
			break;
		    }
		    
		    marker--;
		}
		
		/* All characters above the tag are whitespaces, so this is a Kryptiva body. */
		if (text_status == 3) {
		    kmod_log_msg(3, "mail_get_mail_status(): the Kryptiva marker is at the beginning "
			            "of a text line and all characters above it are whitespace.");
		    text_status = 1;
		}
	    }
	}
	
	/* We did not find the tag, so this is not a Kryptiva body. */
	else {
	    kmod_log_msg(3, "mail_get_mail_status(): the Kryptiva marker has not been found in the text body.\n");
	    text_status = 2;
	}
    }
    
    if (html_body) {
    	char *data = html_body->data;
    	char *marker = portable_strcasestr(data, KRYPTIVA_BODY_START);
	char *before_pre = NULL;
	char *prev_tag_start = NULL;
	char tag_ok_flag = 0;
	
	kmod_log_msg(3, "mail_get_mail_status(): scanning the HTML body.\n");
	
	/* Determine if the tag is OK. */
	do {
	    /* Tag not found. */
	    if (marker == NULL) {
	    	kmod_log_msg(3, "mail_get_mail_status(): the Kryptiva marker has not been found in the HTML body.\n");
	    	break;
	    }
	    
	    kmod_log_msg(3, "mail_get_mail_status(): found the Kryptiva marker in the HTML body.\n");
	    before_pre = mail_remove_pre(data, marker, 1);
	    
	    /* Cannot skip <pre>. */
	    if (before_pre == NULL) {
	    	kmod_log_msg(3, "mail_get_mail_status(): cannot skip HTML <pre> before the Kryptiva marker.\n");
	    	break;
	    }
	    
	    /* Previous character is not '>'. */
	    if (before_pre - 2 < data || before_pre[-1] != '>') {
	    	kmod_log_msg(3, "mail_get_mail_status(): end of previous tag ('>') not found before HTML <pre>.\n");
		break;
	    }
	    
	    /* Skip everything until we reach beginning of mail or '<'. */
	    prev_tag_start = before_pre - 2;
	    while (prev_tag_start != data && *prev_tag_start != '<') prev_tag_start--;
	    
	    /* Start character is not '<'. */
	    if (*prev_tag_start != '<') {
	    	kmod_log_msg(3, "mail_get_mail_status(): start of previous tag ('<') not found before HTML <pre>.\n");
		break;
	    }
	    
	    /* The previous tag is not <body ...> or <html ...>. */
	    if (portable_strncasecmp(prev_tag_start + 1, "body", 4) &&
	    	portable_strncasecmp(prev_tag_start + 1, "html", 4)) {
		kmod_log_msg(3, "mail_get_mail_status(): previous tag before HTML <pre> is not BODY or HTML.\n");
		break;
	    }
	    
	    /* The tag looks ok. */
	    tag_ok_flag = 1;
	    
	} while (0);
    	
    	/* There is no gray zone for HTML bodies: either they are Kryptiva bodies
	 * or they are not.
	 */
	if (tag_ok_flag) {
	    kmod_log_msg(3, "mail_get_mail_status(): the HTML body seems to contain a valid Kryptiva message.\n");
	    html_status = 1;
	}
	
	else {
	    html_status = 2;
	}
    }
    
    kmod_log_msg(3, "mail_get_mail_status(): text status: %d, HTML status: %d.\n", text_status, html_status);
    
    /* Return the decision. */
    decision = decision_table[text_status][html_status];
    
    if (decision == 0) {
    	kmod_log_msg(3, "mail_get_mail_status(): this is a Grey Zone mail.\n");
    }
    
    else if (decision == 1) {
    	kmod_log_msg(3, "mail_get_mail_status(): this is a Kryptiva mail.\n");
    }
    
    else if (decision == 2) {
    	kmod_log_msg(3, "mail_get_mail_status(): this is an Unsigned mail.\n");
    }
    
    else assert(0);
    
    return decision;
}

/* This function extracts the signature from the specified mail body.
 * This function sets the KMO error string. It returns -1 on failure.
 */
int mail_get_signature(kstr *target_body, kstr *sig) {
    char *sig_start, *sig_end;
    
    kmod_log_msg(2, "mail_get_signature() called.\n");
    
    /* Make sure the body is not empty. */
    if (! target_body->slen) {
    	kmo_seterror("empty mail body");
	return -1;
    }
    
    /* Find the last KRYPTIVA_SIG_START tag. */
    sig_start = mail_find_last_tag(target_body->data, KRYPTIVA_SIG_START);
    
    if (sig_start == NULL) {
    	kmo_seterror("Kryptiva signature header not found");
	return -1;
    }
    
    sig_start += strlen(KRYPTIVA_SIG_START);
    sig_end = mail_find_last_tag(sig_start, KRYPTIVA_SIG_END);
    
    if (sig_end == NULL) {
    	kmo_seterror("Kryptiva signature footer not found");
	return -1;
    }
    
    kstr_clear(sig);
    
    /* Remove the whitespace. */
    while (sig_start != sig_end) {
    	if (*sig_start != ' ' && *sig_start != '\n' && *sig_start != '\r' && *sig_start != '\t') {
	    kstr_append_char(sig, *sig_start);
	}
    
	sig_start++;
    }

    return 0;
}

/* This function removes the signature from a text mail.
 * This function sets the KMO error string. It returns -1 on failure.
 */
int mail_strip_text_signature(kstr *body_str, kstr *out_str) {
    char *body_start, *body_end;
    
    kmod_log_msg(2, "mail_strip_text_signature() called.\n");
    
    body_start = portable_strcasestr(body_str->data, KRYPTIVA_BODY_START);
    
    if (body_start == NULL) {
    	kmo_seterror("cannot find body start");
	return -1;
    }
    
    /* Skip PACKAGING TYPE. */
    body_start = portable_strcasestr(body_start + strlen(KRYPTIVA_BODY_START) + 5, "\n");
    
    if (body_start == NULL) {
        kmo_seterror("cannot find packaging type end");
        return -1;
    }
    
    /* Skip the '\n'. */
    body_start++;
    
    body_end = mail_find_last_tag(body_start, KRYPTIVA_INFO_START);

    if (body_end == NULL) {
        kmo_seterror("cannot find body end");
        return -1;
    }
    
    kstr_assign_buf(out_str, body_start, body_end - body_start);
    
    return 0;
}

/* This function removes the signature from an HTML mail.
 * This function sets the KMO error string. It returns -1 on failure.
 */
int mail_strip_html_signature(kstr *raw_body_str, kstr *out_str) {
    int error = 0;
    kstr stripped_body;
    
    kmod_log_msg(2, "mail_strip_html_signature() called.\n");
    
    /* Remove the unwanted data surrounding the HTML payload. */
    kstr_init(&stripped_body);
    mail_get_signable_html_body(raw_body_str, &stripped_body);
    
    /* Try. */
    do {
    	char *marker;
    	char *prolog_start, *prolog_end;
	char *info_start, *info_end;
    	
	/* Find the body marker. */
	marker = portable_strcasestr(stripped_body.data, KRYPTIVA_BODY_START);

	if (marker == NULL) {
            kmo_seterror("cannot find body marker");
            error = -1;
	    break;
	}
	
	/* At this point, we should be in this situation:
	 * beginning of mail...<body or html tag>...whitespaces...<pre>...whitespaces...marker
	 * We want to skip the <pre> and the surrounding whitespaces.
	 */
	prolog_start = mail_remove_pre(stripped_body.data, marker, 1);
	
	if (prolog_start == NULL) {
	    kmo_seterror("cannot find start of body marker");
            error = -1;
	    break;
	}
	
	/* Find the </pre> tag which marks the end of the prolog. */
	prolog_end = portable_strcasestr(marker + strlen(KRYPTIVA_BODY_START), "</pre>");
	
	if (prolog_end == NULL) {
	    kmo_seterror("cannot find end of body marker");
            error = -1;
	    break;
	}
	
	prolog_end += strlen("</pre>");
	
	/* Find the info marker. */
	marker = mail_find_last_tag(prolog_end, KRYPTIVA_INFO_START);
	
	if (marker == NULL) {
            kmo_seterror("cannot find info marker");
            error = -1;
	    break;
	}
	
	/* At this point, we should be in this situation:
	 * UNKNOWN...whitespaces...<pre>...marker...</pre>...whitespaces...</body or /html tag>
	 * We want to skip the text starting from <pre> up to the </body or /html> tag.
	 * Since we inserted a space before the </body or /html> tag when we
	 * packaged the mail, we know we must not skip the whitespaces that appear
	 * before the <pre> tag.
	 */
	info_start = mail_remove_pre(prolog_end, marker, 0);
	
	if (info_start == NULL) {
	    kmo_seterror("cannot find start of info marker");
            error = -1;
	    break;
	}
	
	/* Find the <pre> tag which marks the end of the signature. */
	info_end = portable_strcasestr(marker + strlen(KRYPTIVA_INFO_START), "</pre>");
	
	if (info_end == NULL) {
	    kmo_seterror("cannot find end of info marker");
            error = -1;
	    break;
	}
	
	info_end += strlen("</pre>");
    	
	/* Rewrite the mail without the Kryptiva sections. */
	kstr_clear(out_str);
	kstr_append_buf(out_str, stripped_body.data, prolog_start - stripped_body.data);
	kstr_append_buf(out_str, prolog_end, info_start - prolog_end);
	kstr_append_buf(out_str, info_end, stripped_body.data + stripped_body.slen - info_end);
	
    } while (0);
    
    kstr_free(&stripped_body);
    
    return error;
}

/* This function extracts the encrypted data embedded in an email.
 * Normally the encrypted body data is placed inside a text email.
 * This function sets the KMO error string. It returns -1 on failure.
 */
int mail_get_encrypted_body(kstr *target_body, kstr *out_str) {
    int i = 0;
    char *enc_start, *enc_end;
    
    kmod_log_msg(2, "mail_get_encrypted_body() called.\n");
    
    enc_start = portable_strcasestr(target_body->data, KRYPTIVA_ENC_BODY_START);
    
    if (enc_start == NULL) {
    	kmo_seterror("cannot find encrypted body start");
	return -1;
    }
    
    enc_start += sizeof(KRYPTIVA_ENC_BODY_START);
    enc_end = portable_strcasestr(enc_start, KRYPTIVA_ENC_BODY_END);

    if (enc_end == NULL) {
    	kmo_seterror("cannot find encrypted body end");
	return -1;
    }

    kstr_grow(out_str, enc_end - enc_start);

    /* Remove the newlines */
    while (enc_start != enc_end) {
    	if (*enc_start != ' ' && *enc_start != '\t' && *enc_start != '\n' && *enc_start != '\r') {
	    out_str->data[i] = *enc_start;
	    i++;
	}
	
	enc_start++;
    }
    
    out_str->data[i] = 0;
    out_str->slen = i;
    
    return 0;
}

/* This function parses the address field 'addr_field' and extracts the email 
 * addresses contained within. The extracted addresses are placed in
 * 'addr_array'.
 * This function sets the KMO error string. It returns -1 on failure.
 */
int mail_parse_addr_field(kstr *addr_field, karray *addr_array) {
    int error = 0;
    int i = 0;
    int at_field_end = 0;
    
    kmod_log_msg(2, "mail_parse_addr_field() called.\n");
    
    /* Clear the array. */
    addr_array->size = 0;
    
    /* Split the strings at the ';' character. */
    while (1) {
    	
	/* Create a new address. */
	kstr *addr = kstr_new();
    	
	/* Strip leading spaces. */
	while (addr_field->data[i] == ' ') {
	    i++;
	}
	
	/* Obtain the address data. */
	while (1) {
	    
	    /* We're done. */
    	    if (addr_field->data[i] == 0) {
	    	at_field_end = 1;
	    	break;
	    }
	    
	    /* Found separator. Skip it and stop. */
	    if (addr_field->data[i] == ';') {
	        i++;
	    	break;
	    }
   
	    /* Append data to the address. */
	    kstr_append_char(addr, addr_field->data[i]);
	    i++;
	}
	
	/* We have some address data. */
	if (addr->slen != 0) {
	    
	    /* Strip trailing spaces. */
	    int j = addr->slen - 1;
	    
	    while (addr->data[j] == ' ') {
	    	assert(j > 0);
		j--;
	    }
	    
	    addr->slen = j + 1;
	    addr->data[j + 1] = 0;
	    
	    /* Add the address in the array. */
	    karray_add(addr_array, addr);
	}
	
	/* Destroy the address. */
	else {
	    kstr_destroy(addr);
	}
	
	/* We're done. */
	if (at_field_end) {
	    break;
	}
    }
    
    /* Parse the individual addresses. */
    for (i = 0; i < addr_array->size; i++) {
	char *begin;

	/* Get the next address. */
	kstr *addr = (kstr *) addr_array->data[i];

	/* This is an exchange address. Accept it as is. */
	if (addr->data[0] == '/' && tolower(addr->data[1]) == 'e' &&
	    tolower(addr->data[2]) == 'x' && addr->data[3] == '=') {
	    continue;
	}
	
	/* Look for '<'. */
	begin = strstr(addr->data, "<");

	/* This is a plain address. */
	if (begin == NULL) {
	    /* Nothing to do actually. */
	}

	/* This is something like "John Doe <john_doe@example.com>". */
	else {
	    char *end;
	    int enclosed_len = 0;

	    /* Create the enclosed string. */
	    kstr *enclosed_addr = kstr_new();

	    /* Look for '>'. */
	    end = strstr(begin + 1, ">");

	    /* '>' not found. */
	    if (end == NULL) {
		kstr_destroy(enclosed_addr);
		kmo_seterror("email address is not well formatted (missing closing '>')");
		error = -1;
		break;
	    }

	    /* Compute enclosed address length. */
	    enclosed_len = end - begin - 1;

	    /* We got '<>' */
	    if (! enclosed_len) {
		kstr_destroy(enclosed_addr);
		kmo_seterror("email address is not well formatted (got '<>')");
		error = -1;
		break;
	    }

	    /* Get the enclosed string data. */
	    kstr_mid(addr, enclosed_addr, (begin - addr->data + 1), enclosed_len);

	    /* Replace the raw address by the enclosed address. */
	    kstr_destroy(addr);
	    addr = enclosed_addr;
	    karray_set(addr_array, i, addr);
	}

	/* We have a non-empty address, make sure it contains one and only one '@'. */
	begin = strstr(addr->data, "@");

	if (begin == NULL || strstr(begin + 1, "@")) {
	    kmo_seterror("email address is not well formatted (missing '@')");
	    error = -1;
	    break;
	}
    }
    
    /* Parse error occurred, free everything. */
    if (error) {
    	kmo_clear_kstr_array(addr_array);
    }
    
    return error;
}

